
steps:
# 1. Install npm dependencies
- name: 'gcr.io/cloud-builders/npm'
  id: 'Install dependencies'
  args: ['install']

# 2. Build application, process CSS, and update HTML in a single, consistent environment.
- name: 'gcr.io/cloud-builders/npm'
  id: 'Build application and process assets'
  entrypoint: 'bash'
  args:
    - '-c'
    - |
      # Run esbuild to bundle both index.tsx and its imported CSS.
      # This creates hashed filenames for cache busting and a metafile to map them.
      echo "Running esbuild to bundle application..."
      ./node_modules/.bin/esbuild index.tsx --bundle --outdir=dist --entry-names=[name]-[hash] --minify --sourcemap --metafile=dist/metafile.json \
        --define:process.env.API_KEY="'${_API_KEY}'" \
        --define:process.env.FIREBASE_API_KEY="'${_FIREBASE_API_KEY}'" \
        --define:process.env.FIREBASE_AUTH_DOMAIN="'${_FIREBASE_AUTH_DOMAIN}'" \
        --define:process.env.FIREBASE_PROJECT_ID="'${_FIREBASE_PROJECT_ID}'" \
        --define:process.env.FIREBASE_STORAGE_BUCKET="'${_FIREBASE_STORAGE_BUCKET}'" \
        --define:process.env.FIREBASE_MESSAGING_SENDER_ID="'${_FIREBASE_MESSAGING_SENDER_ID}'" \
        --define:process.env.FIREBASE_APP_ID="'${_FIREBASE_APP_ID}'" \
        --define:process.env.FIREBASE_MEASUREMENT_ID="'${_FIREBASE_MEASUREMENT_ID}'"

      # Extract the final JS and CSS filenames from the esbuild metafile.
      export JS_FILE_PATH=$(cat dist/metafile.json | grep -o '"dist/index-.*\.js"' | tr -d '"')
      export CSS_FILE_PATH=$(cat dist/metafile.json | grep -o '"dist/index-.*\.css"' | tr -d '"')

      # Check if files were found before proceeding.
      if [ -z "$$JS_FILE_PATH" ] || [ -z "$$CSS_FILE_PATH" ]; then
        echo "Error: Could not find hashed JS or CSS file in metafile.json"
        cat dist/metafile.json # Print metafile for debugging
        exit 1
      fi
      
      # Run Tailwind CSS to process src/index.css and output to the hashed file name.
      # This overwrites the unprocessed CSS file that esbuild created with the final, styled version.
      echo "Processing CSS with Tailwind into: $$CSS_FILE_PATH"
      ./node_modules/.bin/tailwindcss -i ./src/index.css -o "$$CSS_FILE_PATH" --minify

      # Use a robust Node.js script to perform the replacement in index.html.
      echo "Updating index.html with JS: $$JS_FILE_PATH and CSS: $$CSS_FILE_PATH"
      cat <<EOF > replace.js
      const fs = require('fs');
      const htmlPath = 'index.html';

      try {
        let content = fs.readFileSync(htmlPath, 'utf8');

        // Note: These placeholder strings MUST match what's in index.html
        content = content.replace('dist/bundle.js', process.env.JS_FILE_PATH);
        content = content.replace('dist/bundle.css', process.env.CSS_FILE_PATH);
        
        fs.writeFileSync(htmlPath, content, 'utf8');
        console.log('Successfully updated index.html with new asset paths.');
      } catch (err) {
        console.error('Error updating index.html:', err);
        process.exit(1);
      }
      EOF

      # Execute the Node.js script to finalize index.html.
      node replace.js

# 3. Remove dev-only scripts from HTML
- name: 'bash'
  id: 'Remove dev scripts from HTML'
  entrypoint: 'bash'
  args:
  - '-c'
  - |
    # Use sed to find the block between the start and end comments and delete it.
    # This removes the Tailwind Play CDN script from the production build.
    sed '/<!-- Tailwind Play CDN for AI Studio development -->/,/<!-- End of Tailwind Play CDN section -->/d' index.html > index.html.tmp && mv index.html.tmp index.html

# 4. Write an nginx config and a Dockerfile on the fly.
#    The nginx config is set up to properly serve a Single-Page Application (SPA).
- name: 'bash'
  entrypoint: 'bash'
  args:
  - '-c'
  - |
    cat <<EOF > nginx.conf
    server {
      listen 8080;
      # Use the default Nginx root directory.
      root /usr/share/nginx/html;
      # Default file to serve.
      index index.html;

      # This location block is a catch-all for any request.
      location / {
        # It first tries to find a file matching the request URI (\$uri).
        # If not found, it falls back to serving /index.html.
        # This is the standard pattern for single-page applications.
        try_files \$uri /index.html;
      }
    }
    EOF

    cat <<EOF > Dockerfile
    # Use a lightweight nginx image
    FROM nginx:1.25-alpine

    # Copy our custom nginx configuration to replace the default one.
    # This config makes nginx listen on port 8080 and serve our SPA.
    COPY nginx.conf /etc/nginx/conf.d/default.conf

    # Copy all the built static assets from the build step into the container's
    # default web root directory.
    COPY ./dist/ /usr/share/nginx/html/dist/
    COPY ./index.html /usr/share/nginx/html/
    COPY ./favicon.svg /usr/share/nginx/html/

    # Expose the port Cloud Run expects
    EXPOSE 8080

    # Start nginx in the foreground
    CMD ["nginx", "-g", "daemon off;"]
    EOF

# 5. Build the docker image using the Dockerfile we just created.
- name: 'gcr.io/cloud-builders/docker'
  args:
  - 'build'
  - '-t'
  - 'us-central1-docker.pkg.dev/$PROJECT_ID/luna-moth-gifts/app:latest'
  - '.'

# 6. Push the final container image to Artifact Registry.
- name: 'gcr.io/cloud-builders/docker'
  args: ['push', 'us-central1-docker.pkg.dev/$PROJECT_ID/luna-moth-gifts/app:latest']

# 7. Deploy the container image to Cloud Run.
- name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
  entrypoint: 'gcloud'
  args:
    - 'run'
    - 'deploy'
    - 'luna-moth-gifts' # The name of your Cloud Run service
    - '--image'
    - 'us-central1-docker.pkg.dev/$PROJECT_ID/luna-moth-gifts/app:latest'
    - '--region'
    - 'us-central1'
    - '--platform'
    - 'managed'
    - '--allow-unauthenticated' # To keep the service public

images:
  - 'us-central1-docker.pkg.dev/$PROJECT_ID/luna-moth-gifts/app:latest'

options:
  logging: CLOUD_LOGGING_ONLY
