
steps:
# 1. Install npm dependencies
- name: 'gcr.io/cloud-builders/npm'
  id: 'Install dependencies'
  args: ['install']

# 2. Build the application, injecting variables directly.
#    esbuild will now handle both JS and CSS, bundling them into hashed files for cache busting.
- name: 'bash'
  id: 'Build application'
  entrypoint: 'bash'
  args:
  - '-c'
  - |
    # Run esbuild to bundle both index.tsx and its imported CSS.
    # --outdir=dist: Puts all output files in the 'dist' directory.
    # --entry-names=[name]-[hash]: This is the core of cache busting. It adds a unique hash to each output file.
    # --metafile=...: Creates a JSON file that maps original filenames to their new hashed versions.
    ./node_modules/.bin/esbuild index.tsx --bundle --outdir=dist --entry-names=[name]-[hash] --minify --sourcemap --metafile=dist/metafile.json \
      --define:process.env.API_KEY="'${_API_KEY}'" \
      --define:process.env.FIREBASE_API_KEY="'${_FIREBASE_API_KEY}'" \
      --define:process.env.FIREBASE_AUTH_DOMAIN="'${_FIREBASE_AUTH_DOMAIN}'" \
      --define:process.env.FIREBASE_PROJECT_ID="'${_FIREBASE_PROJECT_ID}'" \
      --define:process.env.FIREBASE_STORAGE_BUCKET="'${_FIREBASE_STORAGE_BUCKET}'" \
      --define:process.env.FIREBASE_MESSAGING_SENDER_ID="'${_FIREBASE_MESSAGING_SENDER_ID}'" \
      --define:process.env.FIREBASE_APP_ID="'${_FIREBASE_APP_ID}'" \
      --define:process.env.FIREBASE_MEASUREMENT_ID="'${_FIREBASE_MEASUREMENT_ID}'"

# 3. Update index.html to use the new hashed filenames from the metafile
- name: 'bash'
  id: 'Update HTML with hashed filenames'
  entrypoint: 'bash'
  args:
    - '-c'
    - |
      # Extract the final JS and CSS filenames from the esbuild metafile.
      JS_FILE_PATH=$(cat dist/metafile.json | grep -o '"dist/index-.*\.js"' | tr -d '"')
      CSS_FILE_PATH=$(cat dist/metafile.json | grep -o '"dist/index-.*\.css"' | tr -d '"')

      # Check if files were found before proceeding.
      if [ -z "$$JS_FILE_PATH" ] || [ -z "$$CSS_FILE_PATH" ]; then
        echo "Error: Could not find hashed JS or CSS file in metafile.json"
        cat dist/metafile.json # Print metafile for debugging
        exit 1
      fi

      echo "Updating index.html with JS: $$JS_FILE_PATH and CSS: $$CSS_FILE_PATH"

      # Use sed to replace the placeholder paths in index.html.
      # Note: Using a different delimiter like '|' for sed to avoid issues with '/' in file paths.
      sed -i "s|/dist/bundle.js|/$$JS_FILE_PATH|g" index.html
      sed -i "s|/dist/bundle.css|/$$CSS_FILE_PATH|g" index.html

# 4. Remove dev-only scripts from HTML
- name: 'bash'
  id: 'Remove dev scripts from HTML'
  entrypoint: 'bash'
  args:
  - '-c'
  - |
    # Use sed to find the block between the start and end comments and delete it.
    # This removes the Tailwind Play CDN script from the production build.
    sed '/<!-- Tailwind Play CDN for AI Studio development -->/,/<!-- End of Tailwind Play CDN section -->/d' index.html > index.html.tmp && mv index.html.tmp index.html

# 5. Write an nginx config and a Dockerfile on the fly.
#    The nginx config is set up to properly serve a Single-Page Application (SPA).
- name: 'bash'
  entrypoint: 'bash'
  args:
  - '-c'
  - |
    cat <<EOF > nginx.conf
    server {
      listen 8080;
      # Use the default Nginx root directory.
      root /usr/share/nginx/html;
      # Default file to serve.
      index index.html;

      # This location block is a catch-all for any request.
      location / {
        # It first tries to find a file matching the request URI (\$uri).
        # If not found, it falls back to serving /index.html.
        # This is the standard pattern for single-page applications.
        try_files \$uri /index.html;
      }
    }
    EOF

    cat <<EOF > Dockerfile
    # Use a lightweight nginx image
    FROM nginx:1.25-alpine

    # Copy our custom nginx configuration to replace the default one.
    # This config makes nginx listen on port 8080 and serve our SPA.
    COPY nginx.conf /etc/nginx/conf.d/default.conf

    # Copy all the built static assets from the build step into the container's
    # default web root directory.
    COPY ./dist/ /usr/share/nginx/html/dist/
    COPY ./index.html /usr/share/nginx/html/
    COPY ./favicon.svg /usr/share/nginx/html/
    COPY ./images/ /usr/share/nginx/html/images/

    # Expose the port Cloud Run expects
    EXPOSE 8080

    # Start nginx in the foreground
    CMD ["nginx", "-g", "daemon off;"]
    EOF

# 6. Build the docker image using the Dockerfile we just created.
- name: 'gcr.io/cloud-builders/docker'
  args:
  - 'build'
  - '-t'
  - 'us-central1-docker.pkg.dev/$PROJECT_ID/luna-moth-gifts/app:latest'
  - '.'

# 7. Push the final container image to Artifact Registry.
- name: 'gcr.io/cloud-builders/docker'
  args: ['push', 'us-central1-docker.pkg.dev/$PROJECT_ID/luna-moth-gifts/app:latest']

# 8. Deploy the container image to Cloud Run.
- name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
  entrypoint: 'gcloud'
  args:
    - 'run'
    - 'deploy'
    - 'luna-moth-gifts' # The name of your Cloud Run service
    - '--image'
    - 'us-central1-docker.pkg.dev/$PROJECT_ID/luna-moth-gifts/app:latest'
    - '--region'
    - 'us-central1'
    - '--platform'
    - 'managed'
    - '--allow-unauthenticated' # To keep the service public

images:
  - 'us-central1-docker.pkg.dev/$PROJECT_ID/luna-moth-gifts/app:latest'

options:
  logging: CLOUD_LOGGING_ONLY
