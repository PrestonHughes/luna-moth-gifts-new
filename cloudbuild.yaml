steps:
# 1. Create a .env file from Cloud Build substitution variables
- name: 'bash'
  id: 'Create .env file'
  entrypoint: 'bash'
  args:
  - '-c'
  - |
    echo "API_KEY=${_API_KEY}" > .env
    echo "FIREBASE_API_KEY=${_FIREBASE_API_KEY}" >> .env
    echo "FIREBASE_AUTH_DOMAIN=${_FIREBASE_AUTH_DOMAIN}" >> .env
    echo "FIREBASE_PROJECT_ID=${_FIREBASE_PROJECT_ID}" >> .env
    echo "FIREBASE_STORAGE_BUCKET=${_FIREBASE_STORAGE_BUCKET}" >> .env
    echo "FIREBASE_MESSAGING_SENDER_ID=${_FIREBASE_MESSAGING_SENDER_ID}" >> .env
    echo "FIREBASE_APP_ID=${_FIREBASE_APP_ID}" >> .env
    echo "FIREBASE_MEASUREMENT_ID=${_FIREBASE_MEASUREMENT_ID}" >> .env
    echo "Created .env file with secrets for esbuild."

# 2. Install npm dependencies
- name: 'gcr.io/cloud-builders/npm'
  args: ['install']

# 3. Build the application using the .env file
- name: 'gcr.io/cloud-builders/npm'
  args: ['run', 'build']

# 4. Write an nginx config and a Dockerfile on the fly.
#    The nginx config is set up to properly serve a Single-Page Application (SPA).
- name: 'bash'
  entrypoint: 'bash'
  args:
  - '-c'
  - |
    cat <<EOF > nginx.conf
    server {
      listen 8080;
      # Define the root directory for our application files.
      root /app;
      # Default file to serve.
      index index.html;

      # This location block is a catch-all for any request.
      location / {
        # It first tries to find a file matching the request URI (\$uri).
        # If not found, it falls back to serving /index.html.
        # This is the standard pattern for single-page applications.
        try_files \$uri /index.html;
      }
    }
    EOF

    cat <<EOF > Dockerfile
    # Use a lightweight nginx image
    FROM nginx:1.25-alpine

    # Copy our custom nginx configuration to replace the default one.
    # This config makes nginx listen on port 8080 and serve our SPA.
    COPY nginx.conf /etc/nginx/conf.d/default.conf

    # Set the working directory inside the container.
    WORKDIR /app

    # Copy all the built static assets from the build step into the container.
    COPY ./dist/ ./dist/
    COPY ./index.html .
    COPY ./favicon.svg .

    # Expose the port Cloud Run expects
    EXPOSE 8080

    # Start nginx in the foreground
    CMD ["nginx", "-g", "daemon off;"]
    EOF

# 5. Build the docker image using the Dockerfile we just created.
- name: 'gcr.io/cloud-builders/docker'
  args:
  - 'build'
  - '-t'
  - 'us-central1-docker.pkg.dev/$PROJECT_ID/luna-moth-gifts/app:latest'
  - '.'

# 6. Push the final container image to Artifact Registry.
- name: 'gcr.io/cloud-builders/docker'
  args: ['push', 'us-central1-docker.pkg.dev/$PROJECT_ID/luna-moth-gifts/app:latest']

# 7. Deploy the container image to Cloud Run.
- name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
  entrypoint: 'gcloud'
  args:
    - 'run'
    - 'deploy'
    - 'luna-moth-gifts' # The name of your Cloud Run service
    - '--image'
    - 'us-central1-docker.pkg.dev/$PROJECT_ID/luna-moth-gifts/app:latest'
    - '--region'
    - 'us-central1'
    - '--platform'
    - 'managed'
    - '--allow-unauthenticated' # To keep the service public

images:
  - 'us-central1-docker.pkg.dev/$PROJECT_ID/luna-moth-gifts/app:latest'

options:
  logging: CLOUD_LOGGING_ONLY