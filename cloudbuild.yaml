steps:
# 1. Install npm dependencies
- name: 'gcr.io/cloud-builders/npm'
  id: 'Install dependencies'
  args: ['install']

# 2. Build the application, injecting variables directly
- name: 'bash'
  id: 'Build application'
  entrypoint: 'bash'
  args:
  - '-c'
  - |
    # Run esbuild directly from node_modules, passing each environment variable
    # from the Cloud Build substitution variables as a '--define' flag.
    # This replaces 'process.env.VAR_NAME' in the source code with the actual
    # string value at build time. The single and double quotes are important
    # to ensure the values are correctly interpreted as strings by esbuild.
    ./node_modules/.bin/esbuild index.tsx --bundle --outfile=dist/bundle.js --minify --sourcemap \
      --define:process.env.API_KEY="'${_API_KEY}'" \
      --define:process.env.FIREBASE_API_KEY="'${_FIREBASE_API_KEY}'" \
      --define:process.env.FIREBASE_AUTH_DOMAIN="'${_FIREBASE_AUTH_DOMAIN}'" \
      --define:process.env.FIREBASE_PROJECT_ID="'${_FIREBASE_PROJECT_ID}'" \
      --define:process.env.FIREBASE_STORAGE_BUCKET="'${_FIREBASE_STORAGE_BUCKET}'" \
      --define:process.env.FIREBASE_MESSAGING_SENDER_ID="'${_FIREBASE_MESSAGING_SENDER_ID}'" \
      --define:process.env.FIREBASE_APP_ID="'${_FIREBASE_APP_ID}'" \
      --define:process.env.FIREBASE_MEASUREMENT_ID="'${_FIREBASE_MEASUREMENT_ID}'"

# 3. Write an nginx config and a Dockerfile on the fly.
#    The nginx config is set up to properly serve a Single-Page Application (SPA).
- name: 'bash'
  entrypoint: 'bash'
  args:
  - '-c'
  - |
    cat <<EOF > nginx.conf
    server {
      listen 8080;
      # Define the root directory for our application files.
      root /app;
      # Default file to serve.
      index index.html;

      # This location block is a catch-all for any request.
      location / {
        # It first tries to find a file matching the request URI (\$uri).
        # If not found, it falls back to serving /index.html.
        # This is the standard pattern for single-page applications.
        try_files \$uri /index.html;
      }
    }
    EOF

    cat <<EOF > Dockerfile
    # Use a lightweight nginx image
    FROM nginx:1.25-alpine

    # Copy our custom nginx configuration to replace the default one.
    # This config makes nginx listen on port 8080 and serve our SPA.
    COPY nginx.conf /etc/nginx/conf.d/default.conf

    # Set the working directory inside the container.
    WORKDIR /app

    # Copy all the built static assets from the build step into the container.
    COPY ./dist/ ./dist/
    COPY ./index.html .
    COPY ./favicon.svg .

    # Expose the port Cloud Run expects
    EXPOSE 8080

    # Start nginx in the foreground
    CMD ["nginx", "-g", "daemon off;"]
    EOF

# 4. Build the docker image using the Dockerfile we just created.
- name: 'gcr.io/cloud-builders/docker'
  args:
  - 'build'
  - '-t'
  - 'us-central1-docker.pkg.dev/$PROJECT_ID/luna-moth-gifts/app:latest'
  - '.'

# 5. Push the final container image to Artifact Registry.
- name: 'gcr.io/cloud-builders/docker'
  args: ['push', 'us-central1-docker.pkg.dev/$PROJECT_ID/luna-moth-gifts/app:latest']

# 6. Deploy the container image to Cloud Run.
- name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
  entrypoint: 'gcloud'
  args:
    - 'run'
    - 'deploy'
    - 'luna-moth-gifts' # The name of your Cloud Run service
    - '--image'
    - 'us-central1-docker.pkg.dev/$PROJECT_ID/luna-moth-gifts/app:latest'
    - '--region'
    - 'us-central1'
    - '--platform'
    - 'managed'
    - '--allow-unauthenticated' # To keep the service public

images:
  - 'us-central1-docker.pkg.dev/$PROJECT_ID/luna-moth-gifts/app:latest'

options:
  logging: CLOUD_LOGGING_ONLY